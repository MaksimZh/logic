# 1.
Изменение метода в суперклассе меняет его интерфейс.
Поскольку клиентский код использует именно суперкласс в качестве типа переменной,
мы получим ошибку компиляции при вызове метода по старому имени.
Такого метода в суперклассе больше нет.

Это относительно хороший сценарий, потому что ошибка быстро выявляется и хорошо локализуется.
Трудность возникает, если классов-потомков много.
Тогда они, фактически, блокируют изменение интерфейса суперкласса.
Менять метод приходится во всей иерархии классов.

С языками вроде Python, где используется Duck-typing, всё ещё веселее.
Если не использовать линтер и статический анализ типов,
то при изменении интерфейса суперкласса
всегда будет вызываться метод потомка.
Если же нам попадётся потомок без этого метода, то будет ошибка времени выполнения.

В таком случае интерфейс классов-потомков влияет на логику работы программы, использующей суперкласс.


# 2.
У класса потомка две версии метода - с параметром и без.
У родительского класса только один метод.
Поскольку тип переменной - суперкласс,
то в зависимости от того, работает Java скорее как C++ (строгая явная типизация)
или скорее как Python (утиная типизация),
вызов метода с параметром для него будет либо ошибкой компиляции,
либо вызовом метода потомка соответственно.

Второй сценарий, скорее всего, нежелательный.
Это снова скрытое влияние потомков на логику использования суперкласса.
Если имеется в виду именно вызов метода с пареметром, то он и должен быть определён в суперклассе.
В противном случае желательно получить сообщение об ошибке как можно раньше.


# 3.
Код для десериализации и сериализации использует одну и ту же библиотеку,
один и тот же класс и один и тот же экземпляр этого класса.
Если этот экземпляр обладает мутабельным внутренним состоянием (а иначе какой в нём смысл?)
то мы получим целый спектр потенциально нежелательных влияний одного блока кода на другой.

Зависимость этих блоков кода от одной сущности
имеет смысл только если общие сущности присутствуют и на уровне логики.
Это может быть, например, формат сериализации
(возможность переключаться между JSON, XML, ...).
