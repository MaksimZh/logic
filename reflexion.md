# 1. Отделение интерфейса от реализации
В моём решении соединение с БД устанавливается (и удаляется)
самим классом `DatabaseStorage` при каждом действии.
В примере это делает клиентский код.
С точки зрения интерфейса `Storage` это не важно,
потому что реализация методов чтения и записи инкапсулируется.

Исправление неоптимальной работы с соединением
потребует изменений клиентского кода
в относительно небольшом количестве мест -
там где есть завязка на конкретный класс `DatabaseStorage`.


# 2. Почему давно работающий код всё ещё содержит баги
Решение и у меня и в примере выглядит просто и наглядно,
но не учитывает случаи недопустимых (отрицательных) значений.
Если с отрицательными входными данными ещё можно как-то побороться
через систему типов (добавив класс `NonNegativeAmount`, например),
то проверка на достаточность средств всё равно необходима.
Её, впрочем, тоже можно сделать через систему типов.

## Дополнительное задание
Сделал исправление, используя старые наработки,
оставшиеся после изучения ООП.
В примере простой вывод в консоль, а в моём решении -
статусы, привязанные к методам.

Выглядит громоздко, но 3/4 проверок можно убрать,
используя `NonNegativeAmount`.
Пока не стал выходить на уровень системы типов
(вдруг потом будет такое задание),
но взял на заметку, что уже думаю такими категориями.
